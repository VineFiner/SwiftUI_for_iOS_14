- [Meng] Hi and welcome back to session nine of my Swift UI course. Today, we're gonna look into delayed transition and asymmetric transition so that we can open this card, and before even showing the content, which is kind of overlapping with the card, it's going to wait. So it's gonna show the card first, and then the content later. If you scroll down a little bit and look at the transition and replace .opacity with dot, you're gonna find more options such as asymmetric, and then you can see that the type is AnyTransition. Now, what is interesting here is that you can set the animation timing for your transition. So to do that, we're going to remove dot and put AnyTransition.opacity .animation. And this is where we can set the animation timing. In this case, we're gonna use .spring , and because we're using .animation, we can also set multiple animation options. So if you set the value type Animation with capital A, you're gonna be able to set after .spring .delay and set it to 0.3, for example. Let me indent the code a little bit. So we have the transition and then for this transition, we have multiple options such as what kind of transition? In this case, it's opacity. And for that transition, we have the animation timing. Then for the animation timing, we have the spring behavior, but also we added a delay of 0.3 seconds. And I can just put this on the next line. So this is my entire transition with all of these options. To make it more readable lemme just maximize this and let's test this. So I click here and you can see that the content is waiting 0.3 seconds before showing up. But the problem is, this goes both ways, both transition in and transition out. So when I go back, it's also waiting 0.3 seconds. As a result, you can see that both transition in and out are symmetrical. So to solve this, we're gonna use asymmetrical transition. So right before AnyTransition, I'm going to do, dot, and then here we can see asymmetric. So we're gonna select this, double click it, and you can see that it is expecting AnyTransition for both insertion and removal. So let me cut the whole AnyTransition with these modifiers. So command + X, and I'm going to replace insertion. Let's put insertion in its own line, as well as removal. And now we can also paste for the other AnyTransition. But for the second one, which is the removal, this is where we can remove .delay. So remove .delay, including the parentheses as well. And since we only have a single option, we don't need the value type anymore. So now we have opacity and the animation timing. That's pretty cool. So now when I transition in, you can see that the content is waiting. When I transition out, it disappears instantly. Using this technique, you're going to be able to have different animation timings between transition in and out. So let me just fix the indentation here and then remove this extra space. This is where we can start having multiple cards and see what kind of complexity that we're gonna run into. First of all, let's create a V stack, so that we can have a second card. So clicking on a first course item, embed that in a V stack. And then right after the first course item, create another course item, parentheses. Let's use the same size. So let's copy .frame modifier and apply that to the second card. Let's add a bit of spacing. So parentheses for the V stack, spacing 220. So when we click on the card, it's gonna show the full screen, but only between the first course item and the full screen course item. And that's because they're a match. So the first course item has an ID card and this full view course item has the same ID. You can imagine that if we have, let's say 20 cards, each of those cards will have to have a unique ID and that unique ID has to match the full screen ID. So that's where having multiple cards using matched symmetry can get pretty complex and it's not matched symmetry's fault. It's just the way we wanna set up the animations and the transitions that requires a lot of setup. But don't worry, we're going to try the simplest route possible while keeping all the powerful features. Before we move to the next session, let's fix the background color so that it doesn't seem overlapping like this. We're gonna go to the scroll view, and at the end of it, before the transition, we're gonna set .background. We're gonna use one of our color assets. So color, parentheses, it's going to be Background 1. We set up Background 1 to be white for light mode and black for dark mode. So now when we go to full screen, you can see that the content is scrollable and it's not overlapping anymore. Next, we're gonna make this main screen of cards to be scrollable as well. So let's command click on V stack and embed in V stack and replace by a scroll view. Now the content is scrollable, but you're gonna notice that since the scroll view is clipping the content, we have to make sure that the content inside the scroll view takes the full width. And to solve that, we're going to add a modifier for V stack, .frame, parentheses MaxWidth: .infinity Awesome. Now we can see that both of our screens are scrollable and transitioning perfectly. In the next session we're going to play with an array of cards, using a data model. We're going to pass the data to each card so that the content is unique. And then we're going to match the cards using matched symmetry effect. So I'll see you in the next session.