WEBVTT

1
00:00:12.560 --> 00:00:16.050
<v ->大家好，欢迎回到我的Swift UI课程第九节课。</v>

2
00:00:16.050 --> 00:00:20.710
今天，我们将来谈谈延时过渡和非对称过渡

3
00:00:20.710 --> 00:00:23.410
这样我们在打开这个卡片时，

4
00:00:23.410 --> 00:00:24.870
在显示内容前，

5
00:00:24.870 --> 00:00:27.490
该内容与卡片有某种程度的重叠，

6
00:00:27.490 --> 00:00:28.700
需要等一会儿。

7
00:00:28.700 --> 00:00:30.300
它会首先显示这张卡片，

8
00:00:30.300 --> 00:00:32.560
其后才会显示内容。

9
00:00:32.560 --> 00:00:34.290
如果你向下拉一点

10
00:00:34.290 --> 00:00:38.890
并且看着过场动画，同时将.opacity用dot 代替，

11
00:00:38.890 --> 00:00:42.270
你将会发现像非对称等更多的选项，

12
00:00:42.270 --> 00:00:47.130
而那时你会看到该类型是AnyTransition。

13
00:00:47.130 --> 00:00:48.840
现在，在这里有趣的是

14
00:00:48.840 --> 00:00:51.910
你可以为你过场动画

15
00:00:51.910 --> 00:00:53.740
设置动画时间。

16
00:00:53.740 --> 00:00:57.210
那么要这么做，我们要先移去点

17
00:00:57.210 --> 00:01:01.580
并且置入AnyTransition.opacity

18
00:01:02.540 --> 00:01:04.840
.animation。

19
00:01:04.840 --> 00:01:07.570
这里就是我们能够设置动画时间的地方。

20
00:01:07.570 --> 00:01:09.877
在这个案例里，我们将会使用.spring ，

21
00:01:11.650 --> 00:01:13.920
而因为我们正在使用.animation，

22
00:01:13.920 --> 00:01:17.510
我们也可以设置多种动画选项。

23
00:01:17.510 --> 00:01:20.200
那么如果你设置值类型

24
00:01:20.200 --> 00:01:22.520
Animation为大写的A，

25
00:01:22.520 --> 00:01:23.460
你将会可以

26
00:01:23.460 --> 00:01:26.723
在.spring .delay后设置

27
00:01:29.280 --> 00:01:31.780
将它设置为0.3，举例来说。

28
00:01:31.780 --> 00:01:33.870
让我把这段代码稍向后缩一点。

29
00:01:33.870 --> 00:01:37.730
那么我们有了过场动画而对于这个过场动画，

30
00:01:37.730 --> 00:01:41.120
我们有多种选项，如哪种类型的过场动画？

31
00:01:41.120 --> 00:01:42.830
在这个案例里，是透明度。

32
00:01:42.830 --> 00:01:47.600
对于那个过场动画，我们有动画时间。

33
00:01:47.600 --> 00:01:49.530
对于该动画时间，

34
00:01:49.530 --> 00:01:51.890
我们有弹性表现，

35
00:01:51.890 --> 00:01:56.080
但我们也加入了一个0.3秒的延迟。

36
00:01:56.080 --> 00:01:58.860
而我可以把这个放到下一行中。

37
00:01:58.860 --> 00:02:03.120
那么这是我的整个过场动画及其所有这些选项。

38
00:02:03.120 --> 00:02:06.550
要让它更容易阅读让我把这个最大化

39
00:02:06.550 --> 00:02:07.720
让我们测试这个。

40
00:02:07.720 --> 00:02:10.290
那么我点击这里而你就会看到

41
00:02:10.290 --> 00:02:15.100
该内容在显示前等待了0.3秒。

42
00:02:15.100 --> 00:02:18.490
但是问题是，这个是双向的，

43
00:02:18.490 --> 00:02:21.420
在入场动画和离场动画里都有。

44
00:02:21.420 --> 00:02:25.300
那么当我往回看，它也要等待0.3秒。

45
00:02:25.300 --> 00:02:28.220
作为结果，你可以看到这两个入场和离场

46
00:02:28.220 --> 00:02:30.100
动画是对称的。

47
00:02:30.100 --> 00:02:31.540
那么要解决这个问题，

48
00:02:31.540 --> 00:02:34.830
我们将要使用非对称过场动画。

49
00:02:34.830 --> 00:02:39.760
就在AnyTransition前面，我将要做，点，

50
00:02:39.760 --> 00:02:42.660
那么这里我们可以看到非对称。

51
00:02:42.660 --> 00:02:44.290
那么我将要选择这个，

52
00:02:44.290 --> 00:02:45.470
双击它，

53
00:02:45.470 --> 00:02:48.360
你可以看到对于AnyTransition预期的是

54
00:02:48.360 --> 00:02:51.810
插入和移除两者都适用。

55
00:02:51.810 --> 00:02:56.810
那么让我用这些修改器来切割整个AnyTransition，

56
00:02:56.950 --> 00:03:01.923
用Command键+X，我将会替换插入。

57
00:03:02.990 --> 00:03:06.930
让我们将插入放到它自己的行里，

58
00:03:06.930 --> 00:03:09.320
对于移除也是。

59
00:03:09.320 --> 00:03:12.270
而现在我们也可以对于

60
00:03:12.270 --> 00:03:14.690
其它的AnyTransition进行粘贴。

61
00:03:14.690 --> 00:03:17.640
但是对于第二个，也就是移除，

62
00:03:17.640 --> 00:03:21.070
在这里我们可以去掉.delay。

63
00:03:21.070 --> 00:03:25.080
那么移去.delay，包括括号在内。

64
00:03:25.080 --> 00:03:27.240
而由于我们只有一个单独的选项，

65
00:03:27.240 --> 00:03:29.730
我们将不再需要值的类型了。

66
00:03:29.730 --> 00:03:33.180
那么我们现在有了透明和动画时间。

67
00:03:33.180 --> 00:03:34.190
这相当棒。

68
00:03:34.190 --> 00:03:36.250
那么现在当我进行入场动画时，

69
00:03:36.250 --> 00:03:38.340
你可以看到该内容在等待。

70
00:03:38.340 --> 00:03:41.770
而当我进行离场动画时，它立即就消失了。

71
00:03:41.770 --> 00:03:44.010
使用这个技术，你就能够

72
00:03:44.010 --> 00:03:46.020
在入场和离场动画上面

73
00:03:46.020 --> 00:03:48.170
有着不同的动画时间。

74
00:03:48.170 --> 00:03:51.610
那么让我修正这里的缩进

75
00:03:51.610 --> 00:03:54.340
再移去多余的空格。

76
00:03:54.340 --> 00:03:57.650
这里就是我们可以开始有多张卡片

77
00:03:57.650 --> 00:03:59.780
并且看到我们将要运行

78
00:03:59.780 --> 00:04:01.410
哪种程度的复杂度。

79
00:04:01.410 --> 00:04:04.080
首先，让我们创建一个V堆栈，

80
00:04:04.080 --> 00:04:06.200
这样我们可以有了第二张卡片。

81
00:04:06.200 --> 00:04:08.900
那么点击第一段的条目，

82
00:04:08.900 --> 00:04:10.830
将其嵌入到V堆栈中。

83
00:04:10.830 --> 00:04:13.663
然后紧跟着第一段的条目，

84
00:04:14.690 --> 00:04:17.970
创建另一个节的条目，括号。

85
00:04:17.970 --> 00:04:19.290
让我们使用相同的尺寸。

86
00:04:19.290 --> 00:04:22.260
那么让我们复制.frame修改器

87
00:04:22.260 --> 00:04:24.730
并且应用其到第二张卡片。

88
00:04:24.730 --> 00:04:26.150
让我么加一点空格。

89
00:04:26.150 --> 00:04:30.317
对于V堆栈的括号，间距220。

90
00:04:32.330 --> 00:04:34.760
那么当我们点击这张卡片时，

91
00:04:34.760 --> 00:04:36.230
它将会显示全屏，

92
00:04:36.230 --> 00:04:39.520
但仅在第一节的条目

93
00:04:39.520 --> 00:04:41.660
和全屏的条目之间。

94
00:04:41.660 --> 00:04:43.330
因为它们之间是匹配的。

95
00:04:43.330 --> 00:04:47.050
对于第一节的条目有一个标识卡

96
00:04:47.050 --> 00:04:50.710
而对于这个全屏查看的条目有着相同的标识。

97
00:04:50.710 --> 00:04:54.390
你可以想象如果我们有，比方说20张卡片，

98
00:04:54.390 --> 00:04:58.180
而这些卡片的每张必须有一个唯一的标识

99
00:04:58.180 --> 00:05:02.410
而该唯一的标识必须与全屏标识相匹配。

100
00:05:02.410 --> 00:05:04.870
那么当有着多张卡片

101
00:05:04.870 --> 00:05:07.270
使用匹配的对称会带来相当的复杂度

102
00:05:07.270 --> 00:05:09.220
而这与对称的缺陷不匹配。

103
00:05:09.220 --> 00:05:12.190
这只是我们想要设置动画的方式

104
00:05:12.190 --> 00:05:16.110
而过场动画要求许多的设置。

105
00:05:16.110 --> 00:05:16.943
但是别担心，

106
00:05:16.943 --> 00:05:19.270
我们将要尝试可能的最简单的途径

107
00:05:19.270 --> 00:05:22.380
而同时保持所有这些强大的功能。

108
00:05:22.380 --> 00:05:23.880
在我们进入下一节课程前，

109
00:05:23.880 --> 00:05:25.840
让我们修正背景色

110
00:05:25.840 --> 00:05:29.470
以便让它不会像这样重叠。

111
00:05:29.470 --> 00:05:31.280
我们将要卷动视图，

112
00:05:31.280 --> 00:05:33.670
在其尾部，在过场动画前，

113
00:05:33.670 --> 00:05:35.760
我们将要设置.background。

114
00:05:35.760 --> 00:05:38.210
我们将要使用我们其中一个色彩集。

115
00:05:38.210 --> 00:05:42.840
那么颜色，括号，那将会是Background 1。

116
00:05:42.840 --> 00:05:46.160
我们设置Background 1在光照模式时为白色

117
00:05:46.160 --> 00:05:48.380
而在黑暗模式为黑色。

118
00:05:48.380 --> 00:05:50.030
那么现在当我们全屏时，

119
00:05:50.030 --> 00:05:52.300
你可以看到内容是可以滚动查看的

120
00:05:52.300 --> 00:05:54.270
而其它不再重叠了。

121
00:05:54.270 --> 00:05:57.310
下一步，我们将要让这些卡片的主屏幕

122
00:05:57.310 --> 00:05:59.180
也成为可以滚动阅读的。

123
00:05:59.180 --> 00:06:02.040
那么让我们按住命令键点击V堆栈

124
00:06:02.040 --> 00:06:04.220
并嵌入到v堆栈里

125
00:06:04.220 --> 00:06:07.133
并用一个滚动浏览视图来替换。

126
00:06:09.080 --> 00:06:10.620
现在内容是可以滚动浏览的，

127
00:06:10.620 --> 00:06:13.630
但是你将会注意到由于滚动浏览视图

128
00:06:13.630 --> 00:06:15.510
剪短了内容，

129
00:06:15.510 --> 00:06:19.400
我们必须确保在滚动浏览视图里的内容

130
00:06:19.400 --> 00:06:20.950
占用了全部的宽度。

131
00:06:20.950 --> 00:06:23.770
那么要解决该问题，我们准备为V堆栈

132
00:06:23.770 --> 00:06:25.053
增加一个修改器，

133
00:06:26.006 --> 00:06:28.940
.frame，括号

134
00:06:28.940 --> 00:06:29.773
MaxWidth:

135
00:06:31.289 --> 00:06:33.180
.infinity

136
00:06:33.180 --> 00:06:34.013
太棒了。

137
00:06:34.013 --> 00:06:37.500
现在我们可以看到我们的两个屏幕都是可以滚动阅读的

138
00:06:37.500 --> 00:06:40.360
并且过场动画完美。

139
00:06:40.360 --> 00:06:41.930
在下一节课中我们准备要玩

140
00:06:41.930 --> 00:06:45.470
一个卡片矩阵，使用一个数据模型。

141
00:06:45.470 --> 00:06:47.620
我们将会把数据传递给每一张卡片

142
00:06:47.620 --> 00:06:49.680
这样其内容都是独有的。

143
00:06:49.680 --> 00:06:51.490
然后我们准备匹配这些卡片

144
00:06:51.490 --> 00:06:53.720
使用匹配的对称效果。

145
00:06:53.720 --> 00:06:56.209
希望下一节课再次与你会面。

146
00:06:56.209 --> 00:06:57.978
designcode.io

